<!DOCTYPE html>
<html>
<head>
    <title>MediaPipe Face Tracking (Rear Camera)</title>
    <style>
        .container {
            position: relative;
            width: 640px;
            height: 480px;
        }
        .input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 480px;
            z-index: 1;
        }
        .output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 480px;
            z-index: 2;
        }
    </style>
</head>
<body>
    <div class="container">
        <video class="input_video"></video>
        <canvas class="output_canvas" width="640px" height="480px"></canvas>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <script>
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasCtx = canvasElement.getContext('2d');

        let camera;

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(
                results.image, 0, 0, canvasElement.width, canvasElement.height);
            if (results.multiFaceLandmarks) {
                for (const landmarks of results.multiFaceLandmarks) {
                    drawingUtils.drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION,
                                                {color: '#C0C0C070', lineWidth: 1});
                    drawingUtils.drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE,
                                                {color: '#FF3030'});
                    drawingUtils.drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYEBROW,
                                                {color: '#FF3030'});
                    drawingUtils.drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE,
                                                {color: '#30FF30'});
                    drawingUtils.drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYEBROW,
                                                {color: '#30FF30'});
                    drawingUtils.drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL,
                                                {color: '#E0E0E0'});
                    drawingUtils.drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS,
                                                {color: '#E0E0E0'});
                }
            }
            canvasCtx.restore();
        }

        const faceMesh = new FaceMesh({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
        }});
        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        faceMesh.onResults(onResults);

        navigator.mediaDevices.enumerateDevices()
            .then(devices => {
                let rearCameraDeviceId = null;
                const rearCameraKeywords = ['back', 'rear', '背面'];

                devices.forEach(device => {
                    if (device.kind === 'videoinput') {
                        for (const keyword of rearCameraKeywords) {
                            if (device.label.toLowerCase().includes(keyword)) {
                                rearCameraDeviceId = device.deviceId;
                                break;
                            }
                        }
                    }
                });

                const cameraConfig = {
                    onFrame: async () => {
                        await faceMesh.send({image: videoElement});
                    },
                    width: 640,
                    height: 480,
                    facingMode: 'environment' // より直接的に背面カメラを指定を試みる
                };

                if (rearCameraDeviceId) {
                    cameraConfig.deviceId = rearCameraDeviceId;
                    console.log('背面カメラ (deviceId指定) を使用します。');
                } else {
                    console.log('背面カメラ (キーワード検索) に一致するデバイスが見つかりませんでした。facingMode: "environment" を試します。');
                }

                camera = new Camera(videoElement, cameraConfig);
                camera.start();
            })
            .catch(error => {
                console.error('Error getting devices:', error);
            });
    </script>
</body>
</html>
